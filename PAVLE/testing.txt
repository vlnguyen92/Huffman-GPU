
//#if 0
//	//////////////////* DPT KERNEL *///////////////////////////////////
//	//grid_size.x		= num_blocks;
//	//block_size.x	= num_block_threads/DPT;
//	//sm_size			= 2*NUM_SYMBOLS*sizeof(int) + block_size.x*sizeof(unsigned int)+ block_size.x*DPT*sizeof(unsigned int);
//	block_size.x	= num_block_threads;
//	grid_size.x		= num_blocks/DPT;
//	sm_size			= block_size.x*sizeof(unsigned int)+ block_size.x*DPT*sizeof(unsigned int);
//#ifdef CACHECWLUT
//	sm_size			= 2*NUM_SYMBOLS*sizeof(int) + block_size.x*sizeof(unsigned int)+ block_size.x*DPT*sizeof(unsigned int);
//#endif
//	if (sm_size>= MAX_SM_BLOCK_SIZE_GPU) {		printf("Ivalid kernel configuration: Reduce SM requirements!\n");	}
//	else if (block_size.x>256)			 {		printf("Ivalid kernel configuration: Reduce number of threads/block!\n");	}
//	else if (grid_size.x>32*1024)		 {		printf("Ivalid kernel configuration: Reduce number of blocks!\n");	}
//	else {
//	ktime			= 0;
//	CUT_SAFE_CALL(cutResetTimer(timer));
//	CUT_SAFE_CALL(cutStartTimer(timer));
//	for (int i=0; i<NT; i++) {
//	vlc_encode_kernel_dpta<<<grid_size, block_size, sm_size>>>(d_sourceData, d_codewords, d_codewordlens,  
//																					#ifdef TESTING
//																					d_cw32, d_cw32len, d_cw32idx, 
//																					#endif
//																d_destData, d_cindex);//testedOK
//	}
//	cudaThreadSynchronize();
//	CUT_CHECK_ERROR("Kernel execution failed\n");
//	CUT_SAFE_CALL(cutStopTimer(timer));
//	ktime += cutGetTimerValue(timer);
//	//printf("Config. blocks: %d, threads: %d, dpt: %d, sm: %d [B]\n", grid_size.x, block_size.x, DPT, sm_size);
//	printf("GPU Encoding time (DPT): %f (ms)\n", ktime/NT);
//	}
//	//////////////////* END KERNEL *///////////////////////////////////
//#endif
//
//
//#if 0
//	//////////////////* DPTT KERNEL *///////////////////////////////////
//    block_size.x	= num_block_threads;
//	grid_size.x		= num_blocks/DPT;
//	sm_size			= 2*NUM_SYMBOLS*sizeof(int) + block_size.x*sizeof(unsigned int); 
//	#ifdef SMATOMICS
//	sm_size+=block_size.x*DPT*sizeof(unsigned int);
//	#endif
//	if (sm_size>= MAX_SM_BLOCK_SIZE_GPU) {		printf("Ivalid kernel configuration: Reduce SM requirements!\n");	}
//	else if (block_size.x>256)			 {		printf("Ivalid kernel configuration: Reduce number of threads/block!\n");	}
//	else if (grid_size.x>32*1024)		 {		printf("Ivalid kernel configuration: Reduce number of blocks!\n");	}
//	else {
//	ktime			= 0;
//	CUT_SAFE_CALL(cutResetTimer(timer));
//	CUT_SAFE_CALL(cutStartTimer(timer));
//	for (int i=0; i<NT; i++) {
//	vlc_encode_kernel_dptt<<<grid_size, block_size, sm_size>>>(d_sourceData, d_codewords, d_codewordlens,  
//																					#ifdef TESTING
//																					d_cw32, d_cw32len, d_cw32idx, 
//																					#endif
//																					d_destData, d_cindex);//testedOK
//	}
//	cudaThreadSynchronize();
//	CUT_CHECK_ERROR("Kernel execution failed\n");
//	CUT_SAFE_CALL(cutStopTimer(timer));
//	ktime += cutGetTimerValue(timer);
//	printf("GPU Encoding time (DPTT): %f (ms)\n", ktime/NT);
//	}
//	//////////////////* END KERNEL *///////////////////////////////////
//#endif
