/*
 * PAVLE - Parallel Variable-Length Encoder for CUDA
 *
 * Copyright (C) 2009 Ana Balevic <ana.balevic@gmail.com> and Tjark Bringewat <golvellius@gmx.net>
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * MIT License. Read the full licence: http://www.opensource.org/licenses/mit-license.php
 *
 * If you find this program useful, please contact me and reference PAVLE home page in your work.
 * 
 */

#ifndef _VLC_DPTA2_H_
#define _VLC_DPTA2_H_

#include "parameters.h"
#include "pabio_kernels_v2.cu"

__global__ static void vlc_encode_kernel_dpt2(unsigned int *data, const unsigned int *gm_codewords, const unsigned int *gm_codewordlens,
									#ifdef TESTING
										unsigned int *cw32, unsigned int *cw32len, unsigned int *cw32idx,
									#endif
										unsigned int *out, unsigned int *outidx){

	unsigned int kn = (blockIdx.x*blockDim.x + threadIdx.x) * DPT;
	unsigned int k	= threadIdx.x;
	unsigned int kc, numbits, startbit = 0, nmax = 0;

	//unsigned int cwlen = 0;
	int cwlen = 0;	//must be signed for the output with simple shifting!!!
	unsigned int val32;
	unsigned int tmpcw, tmpcwlen;
	unsigned char byte;

	extern __shared__ unsigned int as[];

#ifdef CACHECWLUT
	unsigned int *cw		= as;
	unsigned int *cwlens	= as + NUM_SYMBOLS;
	unsigned int *cw_lens	= as + 2*NUM_SYMBOLS;
	unsigned int *cwbuff	= as + 2*NUM_SYMBOLS + blockDim.x; //ENCODE_THREADS; 
	if (k < NUM_SYMBOLS) {
		cw[k]		= gm_codewords[k];
		cwlens[k]	= gm_codewordlens[k];
		for (unsigned int i=1; i<NUM_SYMBOLS/blockDim.x; i++) {
			cw[k+i*blockDim.x]		= gm_codewords[k+i*blockDim.x];
			cwlens[k+i*blockDim.x]	= gm_codewordlens[k+i*blockDim.x];
		}
	}
	__syncthreads();
	#define CWT		cw
	#define CWLENST cwlens
#else
	unsigned int *cw_lens	= as;
	unsigned int *cwbuff	= as + blockDim.x; //ENCODE_THREADS; 
	#define CWT		gm_codewords
	#define CWLENST gm_codewordlens
#endif

#ifdef CACHESRCDATA
	unsigned int cwlen2 = 0;
	unsigned int cwcache[2*DPT];
	for(unsigned int i=0; i<DPT; i++) 
		cwcache[i] = 0, cwcache[DPT+i]= 0;
#endif //#ifdef CACHESRCDATA

	for(unsigned int i=0; i<DPT; i++) {
		val32 = data[kn+i];								// load original data
		for(unsigned int b=0; b<4; b++) {
			byte =(unsigned char) (val32>>(3-b)*8);
			tmpcwlen = CWLENST[byte];					// code-word length for current byte
			cwlen  += tmpcwlen;							// overall code-word length so far
		#ifdef CACHESRCDATA
			tmpcw	 = CWT[byte];						// code word for current byte
			cwlen2 += tmpcwlen;							// code-word length within the current dword so far
			if (cwlen2 > 31) {
				cwlen2 -= 32;
				cwcache[cwlen/32-1] |= tmpcw >> cwlen2;
			}
			cwcache[cwlen/32] |= tmpcw << 32-cwlen2;
		#endif //#ifdef CACHESRCDATA
		}
	}

	//#ifdef CACHESRCDATA
	//cwcache[cwlen/32] >>= 32-cwlen2;
	//#endif //#ifdef CACHESRCDATA

	cw_lens[k] = cwlen;
	__syncthreads();

	for (unsigned int i=0; i<DPT; i++)
		cwbuff[k*DPT+i] = 0;

	//////////////////////////////////////////////////////
	// Prefix sum of codeword lengths (denoted in bits) [inplace implementation]
	unsigned int offset = 1;

    // Build the sum in place up the tree
	for (unsigned int d = blockDim.x>>1; d>0; d>>=1) {
		if (k < d) {
			unsigned int ai = offset*(2*k+1)-1;
			unsigned int bi = offset*(2*k+2)-1;
			cw_lens[bi] += cw_lens[ai];
		}
		offset *= 2;
		__syncthreads();
	}

	// scan back down the tree
	// clear the last element
	if (k == 0) cw_lens[blockDim.x-1] = 0;
	__syncthreads();

	// traverse down the tree building the scan in place
	for (unsigned int d = 1; d<blockDim.x; d*=2) {
		offset >>= 1;
		if (k < d) {
			unsigned int ai = offset*(2*k+1)-1;
			unsigned int bi = offset*(2*k+2)-1;
			unsigned int t  = cw_lens[ai];
			cw_lens[ai]  = cw_lens[bi];
			cw_lens[bi] += t;
		}
		__syncthreads();
	}
	/////////////////////////

	if (k == blockDim.x-1) outidx[blockIdx.x] = cw_lens[k] + cwlen;

	/* Compute output index kc and startbit position */
	startbit = cw_lens[k] % 32;
	kc = cw_lens[k]/32;

	////////////////////////////////////////////////////

#ifndef CACHESRCDATA
	for(unsigned int i=0; i<DPT; i++) {
		val32 = data[kn+i];	
		for(unsigned int b=0; b<4; b++) {
			byte =(unsigned char) (val32>>(3-b)*8);
			tmpcw	= CWT[byte];
			numbits = CWLENST[byte];					// code-word length for current byte
			if (startbit + numbits > 32) {
				numbits =  startbit + numbits - 32;
				atomicOr(&cwbuff[kc], (tmpcw >> numbits));
				startbit = 0, kc++;
			}
			atomicOr(&cwbuff[kc], (tmpcw << 32-startbit-numbits));
			startbit += numbits; 
		}
	}
#else
	//A1 (shr buffered codes by startbit) //the fastest!
	unsigned int n = 1;
	int restbits;

	tmpcw = cwcache[0]>>startbit;
	atomicOr(&cwbuff[kc], tmpcw);
	restbits = cwlen - (32-startbit);

	while (restbits>0) {
		tmpcw = (cwcache[n-1]<<(32-startbit)) | (cwcache[n]>>startbit);
		atomicOr(&cwbuff[kc+n], tmpcw);
		n++, restbits-=32;
	}

#endif //#ifndef CACHESRCDATA

	////////////////////////////////////////////////////
	__syncthreads();

	unsigned int lastidx = outidx[blockIdx.x]/32;
	for (unsigned int r=0; r<DPT; r++) 
		if ((blockDim.x*r+k)<= lastidx) out[blockIdx.x*blockDim.x*DPT+blockDim.x*r+k] = cwbuff[blockDim.x*r+k]; 


}
#endif
